// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function minNumberOfFlipsRequiredToMakeBinaryGridPalindromic_I(grid) {
  var countPalindromicFlips = function (nums) {
    var _amount = 0;
    var _sliced = nums;
    while(true) {
      var sliced = _sliced;
      var amount = _amount;
      var length = sliced.length;
      if (length < 2) {
        return amount;
      }
      var head = Core__Option.mapOr(nums.at(0), -1, (function (b) {
              return b;
            }));
      var tail = Core__Option.mapOr(nums.at(-1), -1, (function (b) {
              return b;
            }));
      _sliced = sliced.slice(1, length - 1 | 0);
      _amount = head === tail ? amount : amount + 1 | 0;
      continue ;
    };
  };
  var maxRows = grid.length;
  var row = Core__Option.mapOr(grid.at(0), [], (function (r) {
          return r;
        }));
  var maxColumns = row.length;
  var rowLoop = function (_rowFlips, _rowIndex) {
    while(true) {
      var rowIndex = _rowIndex;
      var rowFlips = _rowFlips;
      if (rowIndex === maxRows) {
        return rowFlips;
      }
      var row = Core__Option.mapOr(grid.at(rowIndex), [], (function (r) {
              return r;
            }));
      var count = countPalindromicFlips(row);
      _rowIndex = rowIndex + 1 | 0;
      _rowFlips = rowFlips + count | 0;
      continue ;
    };
  };
  var collectColumnValues = function (columnIndex) {
    var _columnValues = [];
    var _rowIndex = 0;
    while(true) {
      var rowIndex = _rowIndex;
      var columnValues = _columnValues;
      if (rowIndex === maxRows) {
        return columnValues;
      }
      var value = Core__Option.getOr(Core__Option.flatMap(grid.at(rowIndex), (function (row) {
                  return row.at(columnIndex);
                })), -1);
      _rowIndex = rowIndex + 1 | 0;
      _columnValues = columnValues.concat([value]);
      continue ;
    };
  };
  var columnLoop = function (_columnFlips, _columnIndex) {
    while(true) {
      var columnIndex = _columnIndex;
      var columnFlips = _columnFlips;
      if (columnIndex === maxColumns) {
        return columnFlips;
      }
      var columnValues = collectColumnValues(columnIndex);
      var count = countPalindromicFlips(columnValues);
      _columnIndex = columnIndex + 1 | 0;
      _columnFlips = columnFlips + count | 0;
      continue ;
    };
  };
  var rowFlips = rowLoop(0, 0);
  var columnFlips = columnLoop(0, 0);
  if (rowFlips < columnFlips) {
    return rowFlips;
  } else {
    return columnFlips;
  }
}

var g1 = [
  [
    1,
    0,
    0
  ],
  [
    0,
    0,
    0
  ],
  [
    0,
    0,
    1
  ]
];

var r1 = minNumberOfFlipsRequiredToMakeBinaryGridPalindromic_I(g1);

console.log("r1: ", r1);

var g2 = [
  [
    0,
    1
  ],
  [
    0,
    1
  ],
  [
    0,
    0
  ]
];

var r2 = minNumberOfFlipsRequiredToMakeBinaryGridPalindromic_I(g2);

console.log("r2: ", r2);

var g3 = [
  [1],
  [0]
];

var r3 = minNumberOfFlipsRequiredToMakeBinaryGridPalindromic_I(g3);

console.log("r3: ", r3);

export {
  minNumberOfFlipsRequiredToMakeBinaryGridPalindromic_I ,
  g1 ,
  r1 ,
  g2 ,
  r2 ,
  g3 ,
  r3 ,
}
/* r1 Not a pure module */
