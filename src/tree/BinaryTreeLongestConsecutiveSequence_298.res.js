// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function binaryTreeLongestConsecutiveSequence(root) {
  var preorderTraverse = function (_sequences, _stack) {
    while(true) {
      var stack = _stack;
      var sequences = _sequences;
      if (!stack) {
        return sequences;
      }
      var match = stack.hd;
      var node = match[0];
      var val = node.val;
      var rest = stack.tl;
      var sequence = match[1];
      var left = node.left;
      var right = node.right;
      var match$1;
      if (sequence) {
        var restSeq = sequence.tl;
        var prevMaxSeq = sequence.hd;
        match$1 = (val - prevMaxSeq | 0) === 1 ? [
            {
              hd: val,
              tl: {
                hd: prevMaxSeq,
                tl: restSeq
              }
            },
            sequences
          ] : [
            {
              hd: val,
              tl: /* [] */0
            },
            {
              hd: {
                hd: prevMaxSeq,
                tl: restSeq
              },
              tl: sequences
            }
          ];
      } else {
        match$1 = [
          {
            hd: val,
            tl: /* [] */0
          },
          sequences
        ];
      }
      var newSequences = match$1[1];
      var newSequence = match$1[0];
      if (left !== undefined) {
        if (right !== undefined) {
          _stack = {
            hd: [
              left,
              newSequence
            ],
            tl: {
              hd: [
                right,
                newSequence
              ],
              tl: rest
            }
          };
          _sequences = newSequences;
          continue ;
        }
        _stack = {
          hd: [
            left,
            newSequence
          ],
          tl: rest
        };
        _sequences = newSequences;
        continue ;
      }
      if (right !== undefined) {
        _stack = {
          hd: [
            right,
            newSequence
          ],
          tl: rest
        };
        _sequences = newSequences;
        continue ;
      }
      _stack = rest;
      _sequences = {
        hd: newSequence,
        tl: newSequences
      };
      continue ;
    };
  };
  if (root !== undefined) {
    return Core__Option.mapOr(Core__List.toArray(preorderTraverse(/* [] */0, {
                            hd: [
                              root,
                              /* [] */0
                            ],
                            tl: /* [] */0
                          })).toSorted(function (seq1, seq2) {
                      return Caml.int_compare(Core__List.size(seq2), Core__List.size(seq1));
                    }).at(0), -1, (function (longestSeq) {
                  return Core__List.size(longestSeq);
                }));
  } else {
    return -1;
  }
}

var tree1 = TreeNode.make(1, undefined, Caml_option.some(TreeNode.make(3, Caml_option.some(TreeNode.make(2, undefined, undefined)), Caml_option.some(TreeNode.make(4, undefined, Caml_option.some(TreeNode.make(5, undefined, undefined)))))));

var r1 = binaryTreeLongestConsecutiveSequence(tree1);

console.log("r1: ", r1);

var tree2 = TreeNode.make(2, undefined, Caml_option.some(TreeNode.make(3, Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(1, undefined, undefined)), undefined)), undefined)));

var r2 = binaryTreeLongestConsecutiveSequence(tree2);

console.log("r2: ", r2);

export {
  binaryTreeLongestConsecutiveSequence ,
  tree1 ,
  r1 ,
  tree2 ,
  r2 ,
}
/* tree1 Not a pure module */
