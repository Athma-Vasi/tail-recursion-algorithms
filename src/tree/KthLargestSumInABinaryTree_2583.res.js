// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function kthLargestSumInABinaryTree(root, k) {
  var preorderTraverse = function (levelValuesTable, _maxLevel, _stack) {
    while(true) {
      var stack = _stack;
      var maxLevel = _maxLevel;
      if (!stack) {
        return [
                levelValuesTable,
                maxLevel
              ];
      }
      var match = stack.hd;
      var node = match[0];
      var right = node.right;
      var left = node.left;
      var val = node.val;
      var rest = stack.tl;
      var level = match[1];
      var values = Core__Option.mapOr(levelValuesTable.get(level), {
            hd: val,
            tl: /* [] */0
          }, (function(val){
          return function (vals) {
            return {
                    hd: val,
                    tl: vals
                  };
          }
          }(val)));
      levelValuesTable.set(level, values);
      var newMaxLevel = maxLevel > level ? maxLevel : level;
      if (left !== undefined) {
        if (right !== undefined) {
          _stack = {
            hd: [
              left,
              level + 1 | 0
            ],
            tl: {
              hd: [
                right,
                level + 1 | 0
              ],
              tl: rest
            }
          };
          _maxLevel = newMaxLevel;
          continue ;
        }
        _stack = {
          hd: [
            left,
            level + 1 | 0
          ],
          tl: rest
        };
        _maxLevel = newMaxLevel;
        continue ;
      }
      if (right !== undefined) {
        _stack = {
          hd: [
            right,
            level + 1 | 0
          ],
          tl: rest
        };
        _maxLevel = newMaxLevel;
        continue ;
      }
      _stack = rest;
      _maxLevel = newMaxLevel;
      continue ;
    };
  };
  if (root === undefined) {
    return -1;
  }
  var match = preorderTraverse(new Map(), -1, {
        hd: [
          root,
          0
        ],
        tl: /* [] */0
      });
  if (match[1] < (k - 1 | 0)) {
    return -1;
  } else {
    return Core__Option.mapOr(Core__List.toArray(Core__Array.reduce(Array.from(match[0].values()), /* [] */0, (function (acc, values) {
                              return {
                                      hd: Core__List.reduce(values, 0, (function (sum, val) {
                                              return sum + val | 0;
                                            })),
                                      tl: acc
                                    };
                            }))).toSorted(function (v1, v2) {
                      return Caml.int_compare(v2, v1);
                    }).at(k - 1 | 0), -1, (function (n) {
                  return n;
                }));
  }
}

var tree1 = TreeNode.make(5, Caml_option.some(TreeNode.make(8, Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(4, undefined, undefined)), Caml_option.some(TreeNode.make(6, undefined, undefined)))), Caml_option.some(TreeNode.make(1, undefined, undefined)))), Caml_option.some(TreeNode.make(9, Caml_option.some(TreeNode.make(3, undefined, undefined)), Caml_option.some(TreeNode.make(7, undefined, undefined)))));

var r1 = kthLargestSumInABinaryTree(tree1, 2);

console.log("r1: ", r1);

var tree2 = TreeNode.make(1, Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(3, undefined, undefined)), undefined)), undefined);

var r2 = kthLargestSumInABinaryTree(tree2, 1);

console.log("r2: ", r2);

export {
  kthLargestSumInABinaryTree ,
  tree1 ,
  r1 ,
  tree2 ,
  r2 ,
}
/* tree1 Not a pure module */
