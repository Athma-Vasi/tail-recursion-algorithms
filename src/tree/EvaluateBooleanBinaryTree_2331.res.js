// Generated by ReScript, PLEASE EDIT WITH CARE

import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function evaluateBooleanBinaryTree(root) {
  var postorderTraverse = function (_rpnStack, _workingStack) {
    while(true) {
      var workingStack = _workingStack;
      var rpnStack = _rpnStack;
      if (!workingStack) {
        return rpnStack;
      }
      var top = workingStack.hd;
      var val = top.val;
      var rest = workingStack.tl;
      var left = top.left;
      var right = top.right;
      if (left !== undefined) {
        if (right !== undefined) {
          _workingStack = {
            hd: right,
            tl: {
              hd: left,
              tl: rest
            }
          };
          _rpnStack = {
            hd: [
              val,
              "Branch"
            ],
            tl: rpnStack
          };
          continue ;
        }
        _workingStack = {
          hd: left,
          tl: rest
        };
        _rpnStack = {
          hd: [
            val,
            "Branch"
          ],
          tl: rpnStack
        };
        continue ;
      }
      if (right !== undefined) {
        _workingStack = {
          hd: right,
          tl: rest
        };
        _rpnStack = {
          hd: [
            val,
            "Branch"
          ],
          tl: rpnStack
        };
        continue ;
      }
      _workingStack = rest;
      _rpnStack = {
        hd: [
          val,
          "Leaf"
        ],
        tl: rpnStack
      };
      continue ;
    };
  };
  var processResults = function (_evaluationStack, _rpnStack) {
    while(true) {
      var rpnStack = _rpnStack;
      var evaluationStack = _evaluationStack;
      if (!rpnStack) {
        return evaluationStack;
      }
      var rest = rpnStack.tl;
      var match = rpnStack.hd;
      var val = match[0];
      if (match[1] === "Leaf") {
        _rpnStack = rest;
        _evaluationStack = {
          hd: val === 1,
          tl: evaluationStack
        };
        continue ;
      }
      var match$1 = Core__List.reduceWithIndex(evaluationStack, [
            false,
            false
          ], (function (acc, curr, idx) {
              if (idx === 1) {
                return [
                        curr,
                        acc[1]
                      ];
              } else {
                return [
                        acc[0],
                        curr
                      ];
              }
            }));
      var rightBool = match$1[1];
      var leftBool = match$1[0];
      if (val !== 2) {
        _rpnStack = rest;
        _evaluationStack = {
          hd: leftBool && rightBool,
          tl: /* [] */0
        };
        continue ;
      }
      _rpnStack = rest;
      _evaluationStack = {
        hd: leftBool || rightBool,
        tl: /* [] */0
      };
      continue ;
    };
  };
  if (root !== undefined) {
    return Core__Option.mapOr(Core__List.head(processResults(/* [] */0, postorderTraverse(/* [] */0, {
                            hd: root,
                            tl: /* [] */0
                          }))), false, (function (h) {
                  return h;
                }));
  } else {
    return false;
  }
}

var l1 = TreeNode.make(0, undefined, undefined);

var l2 = TreeNode.make(1, undefined, undefined);

var l3 = TreeNode.make(1, undefined, undefined);

var l4 = TreeNode.make(0, undefined, undefined);

var andNode = TreeNode.make(3, Caml_option.some(l1), Caml_option.some(l2));

var orNode = TreeNode.make(2, Caml_option.some(l3), Caml_option.some(l4));

var root = TreeNode.make(3, Caml_option.some(andNode), Caml_option.some(orNode));

var r1 = evaluateBooleanBinaryTree(root);

console.log("r1: ", r1);

export {
  evaluateBooleanBinaryTree ,
  l1 ,
  l2 ,
  l3 ,
  l4 ,
  andNode ,
  orNode ,
  root ,
  r1 ,
}
/* l1 Not a pure module */
