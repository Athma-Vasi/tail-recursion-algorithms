// Generated by ReScript, PLEASE EDIT WITH CARE

import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";

function boundaryOfBinaryTree(root) {
  var collectLeaves = function (_leaves, _stack) {
    while(true) {
      var stack = _stack;
      var leaves = _leaves;
      if (!stack) {
        return Core__List.reverse(leaves);
      }
      var node = stack.hd;
      var rest = stack.tl;
      var left = node.left;
      var right = node.right;
      if (left !== undefined) {
        if (right !== undefined) {
          _stack = {
            hd: left,
            tl: {
              hd: right,
              tl: rest
            }
          };
          continue ;
        }
        _stack = {
          hd: left,
          tl: rest
        };
        continue ;
      }
      if (right !== undefined) {
        _stack = {
          hd: right,
          tl: rest
        };
        continue ;
      }
      _stack = rest;
      _leaves = {
        hd: node.val,
        tl: leaves
      };
      continue ;
    };
  };
  var leftSideView = function (levelLeftmostTable, _stack) {
    while(true) {
      var stack = _stack;
      if (!stack) {
        return Core__Array.reduceRight(Array.from(levelLeftmostTable.entries()), /* [] */0, (function (acc, param) {
                      return {
                              hd: param[1],
                              tl: acc
                            };
                    }));
      }
      var match = stack.hd;
      var node = match[0];
      var rest = stack.tl;
      var level = match[1];
      var left = node.left;
      var right = node.right;
      levelLeftmostTable.set(level, node.val);
      if (left !== undefined) {
        if (right !== undefined) {
          _stack = {
            hd: [
              right,
              level + 1 | 0
            ],
            tl: {
              hd: [
                left,
                level + 1 | 0
              ],
              tl: rest
            }
          };
          continue ;
        }
        _stack = {
          hd: [
            left,
            level + 1 | 0
          ],
          tl: rest
        };
        continue ;
      }
      if (right !== undefined) {
        _stack = {
          hd: [
            right,
            level + 1 | 0
          ],
          tl: rest
        };
        continue ;
      }
      _stack = rest;
      continue ;
    };
  };
  var rightSideView = function (levelRightmostTable, _stack) {
    while(true) {
      var stack = _stack;
      if (!stack) {
        return Core__List.reverse(Core__Array.reduceRight(Array.from(levelRightmostTable.entries()), /* [] */0, (function (acc, param) {
                          return {
                                  hd: param[1],
                                  tl: acc
                                };
                        })));
      }
      var match = stack.hd;
      var node = match[0];
      var rest = stack.tl;
      var level = match[1];
      var left = node.left;
      var right = node.right;
      levelRightmostTable.set(level, node.val);
      if (left !== undefined) {
        if (right !== undefined) {
          _stack = {
            hd: [
              left,
              level + 1 | 0
            ],
            tl: {
              hd: [
                right,
                level + 1 | 0
              ],
              tl: rest
            }
          };
          continue ;
        }
        _stack = {
          hd: [
            left,
            level + 1 | 0
          ],
          tl: rest
        };
        continue ;
      }
      if (right !== undefined) {
        _stack = {
          hd: [
            right,
            level + 1 | 0
          ],
          tl: rest
        };
        continue ;
      }
      _stack = rest;
      continue ;
    };
  };
  if (root === undefined) {
    return [];
  }
  var leftBoundary = leftSideView(new Map(), {
        hd: [
          root,
          0
        ],
        tl: /* [] */0
      });
  var leaves = collectLeaves(/* [] */0, {
        hd: root,
        tl: /* [] */0
      });
  var rightBoundary = rightSideView(new Map(), {
        hd: [
          root,
          0
        ],
        tl: /* [] */0
      });
  return Array.from(Core__Array.reduce([
                    leftBoundary,
                    leaves,
                    rightBoundary
                  ], new Set(), (function (acc, curr) {
                      Core__List.forEach(curr, (function (v) {
                              acc.add(v);
                            }));
                      return acc;
                    })).values());
}

var tree1 = TreeNode.make(1, undefined, Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(3, undefined, undefined)), Caml_option.some(TreeNode.make(4, undefined, undefined)))));

var r1 = boundaryOfBinaryTree(tree1);

console.log("r1: ", r1);

var tree2 = TreeNode.make(1, Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(4, undefined, undefined)), Caml_option.some(TreeNode.make(5, Caml_option.some(TreeNode.make(7, undefined, undefined)), Caml_option.some(TreeNode.make(8, undefined, undefined)))))), Caml_option.some(TreeNode.make(3, Caml_option.some(TreeNode.make(6, Caml_option.some(TreeNode.make(9, undefined, undefined)), Caml_option.some(TreeNode.make(10, undefined, undefined)))), undefined)));

var r2 = boundaryOfBinaryTree(tree2);

console.log("r2: ", r2);

export {
  boundaryOfBinaryTree ,
  tree1 ,
  r1 ,
  tree2 ,
  r2 ,
}
/* tree1 Not a pure module */
