// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Int32 from "rescript/lib/es6/int32.js";
import * as TreeNode from "./TreeNode.res.js";
import * as Core__Int from "@rescript/core/src/Core__Int.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function findDuplicateSubtrees(root) {
  var postorderTraverse = function (_rpnStack, _workingStack) {
    while(true) {
      var workingStack = _workingStack;
      var rpnStack = _rpnStack;
      if (!workingStack) {
        return rpnStack;
      }
      var node = workingStack.hd;
      var right = node.right;
      var left = node.left;
      var val = node.val;
      var rest = workingStack.tl;
      if (left !== undefined) {
        if (right !== undefined) {
          _workingStack = {
            hd: right,
            tl: {
              hd: left,
              tl: rest
            }
          };
          _rpnStack = {
            hd: [
              val,
              "Branch"
            ],
            tl: rpnStack
          };
          continue ;
        }
        _workingStack = {
          hd: left,
          tl: rest
        };
        _rpnStack = {
          hd: [
            val,
            "Branch"
          ],
          tl: rpnStack
        };
        continue ;
      }
      if (right !== undefined) {
        _workingStack = {
          hd: right,
          tl: rest
        };
        _rpnStack = {
          hd: [
            val,
            "Branch"
          ],
          tl: rpnStack
        };
        continue ;
      }
      _workingStack = rest;
      _rpnStack = {
        hd: [
          val,
          "Leaf"
        ],
        tl: rpnStack
      };
      continue ;
    };
  };
  if (root !== undefined) {
    var _rpnStack = postorderTraverse(/* [] */0, {
          hd: root,
          tl: /* [] */0
        });
    var freqTable = new Map();
    var _duplicates = [];
    var _evaluationStack = /* [] */0;
    while(true) {
      var evaluationStack = _evaluationStack;
      var duplicates = _duplicates;
      var rpnStack = _rpnStack;
      if (!rpnStack) {
        return duplicates;
      }
      var rest = rpnStack.tl;
      var match = rpnStack.hd;
      var nodeKind = match[1];
      var val = match[0];
      if (nodeKind === "Leaf") {
        _evaluationStack = {
          hd: [
            val,
            nodeKind
          ],
          tl: evaluationStack
        };
        _rpnStack = rest;
        continue ;
      }
      var match$1 = Core__List.reduceWithIndex(evaluationStack, [
            val.toString(),
            /* [] */0
          ], (function (acc, curr, idx) {
              var nodeKind = curr[1];
              var val = curr[0];
              var sliced = acc[1];
              var serialized = acc[0];
              if (idx < 2 && nodeKind === "Leaf") {
                return [
                        serialized + val.toString(),
                        sliced
                      ];
              } else {
                return [
                        serialized,
                        {
                          hd: [
                            val,
                            nodeKind
                          ],
                          tl: sliced
                        }
                      ];
              }
            }));
      var serialized = match$1[0];
      var original = Core__List.reverse(match$1[1]);
      var freq = freqTable.get(serialized);
      if (freq !== undefined) {
        freqTable.set(serialized, freq + 1 | 0);
        var unserialized = serialized.split(String()).map(function ($$char) {
              return Core__Option.mapOr(Core__Int.fromString($$char, undefined), Int32.min_int, (function (c) {
                            return c;
                          }));
            });
        var newDuplicates = [
          unserialized,
          [Core__Option.mapOr(unserialized.at(1), Int32.min_int, (function (v) {
                    return v;
                  }))]
        ];
        _evaluationStack = {
          hd: [
            val,
            nodeKind
          ],
          tl: original
        };
        _duplicates = newDuplicates;
        _rpnStack = rest;
        continue ;
      }
      freqTable.set(serialized, 1);
      _evaluationStack = {
        hd: [
          val,
          nodeKind
        ],
        tl: original
      };
      _rpnStack = rest;
      continue ;
    };
  } else {
    return [];
  }
}

var tree1 = TreeNode.make(1, Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(4, undefined, undefined)), undefined)), Caml_option.some(TreeNode.make(3, Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(4, undefined, undefined)), undefined)), Caml_option.some(TreeNode.make(4, undefined, undefined)))));

var r1 = findDuplicateSubtrees(tree1);

console.log("r1: ", r1);

export {
  findDuplicateSubtrees ,
  tree1 ,
  r1 ,
}
/* tree1 Not a pure module */
