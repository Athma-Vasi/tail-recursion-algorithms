// Generated by ReScript, PLEASE EDIT WITH CARE

import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function smallestSubtreeWithAllTheDeepestNodes(root) {
  var postorderTraverse = function (_maxDepth, _rpnStack, _workingStack) {
    while(true) {
      var workingStack = _workingStack;
      var rpnStack = _rpnStack;
      var maxDepth = _maxDepth;
      if (!workingStack) {
        return [
                maxDepth,
                rpnStack
              ];
      }
      var match = workingStack.hd;
      var node = match[0];
      var val = node.val;
      var rest = workingStack.tl;
      var depth = match[1];
      var left = node.left;
      var right = node.right;
      var newMaxDepth = maxDepth > depth ? maxDepth : depth;
      if (left !== undefined) {
        if (right !== undefined) {
          _workingStack = {
            hd: [
              left,
              depth + 1 | 0
            ],
            tl: {
              hd: [
                right,
                depth + 1 | 0
              ],
              tl: rest
            }
          };
          _rpnStack = {
            hd: [
              depth,
              val,
              "Branch"
            ],
            tl: rpnStack
          };
          _maxDepth = newMaxDepth;
          continue ;
        }
        _workingStack = {
          hd: [
            left,
            depth + 1 | 0
          ],
          tl: rest
        };
        _rpnStack = {
          hd: [
            depth,
            val,
            "Branch"
          ],
          tl: rpnStack
        };
        _maxDepth = newMaxDepth;
        continue ;
      }
      if (right !== undefined) {
        _workingStack = {
          hd: [
            right,
            depth + 1 | 0
          ],
          tl: rest
        };
        _rpnStack = {
          hd: [
            depth,
            val,
            "Branch"
          ],
          tl: rpnStack
        };
        _maxDepth = newMaxDepth;
        continue ;
      }
      _workingStack = rest;
      _rpnStack = {
        hd: [
          depth,
          val,
          "Leaf"
        ],
        tl: rpnStack
      };
      _maxDepth = newMaxDepth;
      continue ;
    };
  };
  var processRPNStack = function (_evaluationStack, maxDepth, _rpnStack) {
    while(true) {
      var rpnStack = _rpnStack;
      var evaluationStack = _evaluationStack;
      if (!rpnStack) {
        return evaluationStack;
      }
      var rest = rpnStack.tl;
      var match = rpnStack.hd;
      var nodeKind = match[2];
      var val = match[1];
      var depth = match[0];
      var match$1 = depth === maxDepth;
      if (match$1) {
        if (nodeKind === "Leaf") {
          _rpnStack = rest;
          _evaluationStack = {
            hd: val,
            tl: evaluationStack
          };
          continue ;
        }
        _rpnStack = rest;
        continue ;
      }
      if (nodeKind === "Leaf") {
        _rpnStack = rest;
        continue ;
      }
      _rpnStack = rest;
      _evaluationStack = depth === (maxDepth - 1 | 0) ? ({
            hd: val,
            tl: evaluationStack
          }) : evaluationStack;
      continue ;
    };
  };
  if (root === undefined) {
    return [];
  }
  var match = postorderTraverse(-1, /* [] */0, {
        hd: [
          root,
          0
        ],
        tl: /* [] */0
      });
  return Core__List.toArray(processRPNStack(/* [] */0, match[0], match[1]));
}

var node7 = TreeNode.make(7, undefined, undefined);

var node4 = TreeNode.make(4, undefined, undefined);

var node2 = TreeNode.make(2, Caml_option.some(node7), Caml_option.some(node4));

var node6 = TreeNode.make(6, undefined, undefined);

var node0 = TreeNode.make(0, undefined, undefined);

var node8 = TreeNode.make(8, undefined, undefined);

var node5 = TreeNode.make(5, Caml_option.some(node6), Caml_option.some(node2));

var node1 = TreeNode.make(1, Caml_option.some(node0), Caml_option.some(node8));

var root = TreeNode.make(3, Caml_option.some(node5), Caml_option.some(node1));

var r1 = smallestSubtreeWithAllTheDeepestNodes(root);

console.log("r1: ", r1);

export {
  smallestSubtreeWithAllTheDeepestNodes ,
  node7 ,
  node4 ,
  node2 ,
  node6 ,
  node0 ,
  node8 ,
  node5 ,
  node1 ,
  root ,
  r1 ,
}
/* node7 Not a pure module */
