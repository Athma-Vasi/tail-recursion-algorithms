// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function minNumberOfOpsToSortBinaryTreeByLevel(root) {
  var breadthFirstTraverse = function (levelValuesTable, _queue) {
    while(true) {
      var queue = _queue;
      if (!queue) {
        return levelValuesTable;
      }
      var match = queue.hd;
      var node = match[0];
      var val = node.val;
      var rest = queue.tl;
      var level = match[1];
      var left = node.left;
      var right = node.right;
      var values = Core__Option.mapOr(levelValuesTable.get(level), {
            hd: val,
            tl: /* [] */0
          }, (function(val){
          return function (vals) {
            return {
                    hd: val,
                    tl: vals
                  };
          }
          }(val)));
      levelValuesTable.set(level, values);
      if (left !== undefined) {
        if (right !== undefined) {
          _queue = Core__List.concat(rest, {
                hd: [
                  left,
                  level + 1 | 0
                ],
                tl: {
                  hd: [
                    right,
                    level + 1 | 0
                  ],
                  tl: /* [] */0
                }
              });
          continue ;
        }
        _queue = Core__List.concat(rest, {
              hd: [
                left,
                level + 1 | 0
              ],
              tl: /* [] */0
            });
        continue ;
      }
      if (right !== undefined) {
        _queue = Core__List.concat(rest, {
              hd: [
                right,
                level + 1 | 0
              ],
              tl: /* [] */0
            });
        continue ;
      }
      _queue = rest;
      continue ;
    };
  };
  var getMinimumSwaps = function (values) {
    var _swaps = 0;
    var valuesPositionsTable = Core__Array.reduceWithIndex(values, new Map(), (function (acc, curr, idx) {
            acc.set(curr, idx);
            return acc;
          }));
    var _cloned = values.map(function (v) {
          return v;
        });
    var sorted = values.toSorted(Caml.int_compare);
    var _index = 0;
    while(true) {
      var index = _index;
      var cloned = _cloned;
      var swaps = _swaps;
      if (index === cloned.length) {
        return swaps;
      }
      var originalValue = Core__Option.mapOr(cloned.at(index), -1, (function (v) {
              return v;
            }));
      var sortedValue = Core__Option.mapOr(sorted.at(index), -1, (function (v) {
              return v;
            }));
      if (originalValue === sortedValue) {
        _index = index + 1 | 0;
        continue ;
      }
      var currPosition = Core__Option.mapOr(valuesPositionsTable.get(sortedValue), -1, (function (p) {
              return p;
            }));
      valuesPositionsTable.set(originalValue, currPosition);
      _index = index + 1 | 0;
      _cloned = cloned.map((function(originalValue,currPosition){
          return function (val, idx) {
            if (idx === currPosition) {
              return originalValue;
            } else {
              return val;
            }
          }
          }(originalValue,currPosition)));
      _swaps = swaps + 1 | 0;
      continue ;
    };
  };
  if (root !== undefined) {
    return Core__Array.reduce(Array.from(breadthFirstTraverse(new Map(), {
                          hd: [
                            root,
                            0
                          ],
                          tl: /* [] */0
                        }).values()), 0, (function (acc, curr) {
                  return acc + getMinimumSwaps(Core__List.toArray(Core__List.reverse(curr))) | 0;
                }));
  } else {
    return 0;
  }
}

var node10 = TreeNode.make(10, undefined, undefined);

var node9 = TreeNode.make(9, undefined, Caml_option.some(node10));

var node5 = TreeNode.make(5, undefined, Caml_option.some(node9));

var node8 = TreeNode.make(8, undefined, undefined);

var node6 = TreeNode.make(6, undefined, undefined);

var node7 = TreeNode.make(7, undefined, undefined);

var node4 = TreeNode.make(4, Caml_option.some(node7), Caml_option.some(node6));

var node3 = TreeNode.make(3, Caml_option.some(node8), Caml_option.some(node5));

var root2 = TreeNode.make(1, Caml_option.some(node4), Caml_option.some(node3));

var r2 = minNumberOfOpsToSortBinaryTreeByLevel(root2);

console.log("r2: ", r2);

export {
  minNumberOfOpsToSortBinaryTreeByLevel ,
  node10 ,
  node9 ,
  node5 ,
  node8 ,
  node6 ,
  node7 ,
  node4 ,
  node3 ,
  root2 ,
  r2 ,
}
/* node10 Not a pure module */
