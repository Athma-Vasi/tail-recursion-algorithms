// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Int32 from "rescript/lib/es6/int32.js";
import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function symmetricTree(root) {
  var breadthFirstTraverse = function (levelValuesTable, _stack) {
    while(true) {
      var stack = _stack;
      if (!stack) {
        return levelValuesTable;
      }
      var match = stack.hd;
      var poppedNode = match[0];
      var right = poppedNode.right;
      var left = poppedNode.left;
      var val = poppedNode.val;
      var rest = stack.tl;
      var level = match[1];
      var values = Core__Option.mapOr(levelValuesTable.get(level), {
            hd: val,
            tl: /* [] */0
          }, (function(val){
          return function (vals) {
            return {
                    hd: val,
                    tl: vals
                  };
          }
          }(val)));
      levelValuesTable.set(level, values);
      if (left !== undefined) {
        if (right !== undefined) {
          _stack = {
            hd: [
              left,
              level + 1 | 0
            ],
            tl: {
              hd: [
                right,
                level + 1 | 0
              ],
              tl: rest
            }
          };
          continue ;
        }
        _stack = {
          hd: [
            left,
            level + 1 | 0
          ],
          tl: rest
        };
        continue ;
      }
      if (right !== undefined) {
        _stack = {
          hd: [
            right,
            level + 1 | 0
          ],
          tl: rest
        };
        continue ;
      }
      _stack = rest;
      continue ;
    };
  };
  var checkIsPalindrome = function (items) {
    var checks = new Set();
    var _sliced = Core__List.toArray(items);
    while(true) {
      var sliced = _sliced;
      var length = sliced.length;
      if (length === 0) {
        return !checks.has(false);
      }
      var match = Core__Array.reduceWithIndex(sliced, [
            [
              Int32.min_int,
              Int32.max_int
            ],
            []
          ], (function(length){
          return function (acc, num, idx) {
            var newSliced = acc[1];
            var match = acc[0];
            var last = match[1];
            if (idx === 0) {
              return [
                      [
                        num,
                        last
                      ],
                      newSliced
                    ];
            }
            var first = match[0];
            if (idx === (length - 1 | 0)) {
              return [
                      [
                        first,
                        num
                      ],
                      newSliced
                    ];
            } else {
              return [
                      [
                        first,
                        last
                      ],
                      newSliced.concat([num])
                    ];
            }
          }
          }(length)));
      var match$1 = match[0];
      checks.add(match$1[0] === match$1[1]);
      _sliced = match[1];
      continue ;
    };
  };
  if (root === undefined) {
    return true;
  }
  var checks = Core__Array.reduce(Array.from(breadthFirstTraverse(new Map(), {
                  hd: [
                    root,
                    0
                  ],
                  tl: /* [] */0
                }).entries()), new Set(), (function (acc, param) {
          acc.add(param[0] === 0 ? true : checkIsPalindrome(param[1]));
          return acc;
        }));
  return !checks.has(false);
}

var n5 = TreeNode.make(5, Caml_option.some(TreeNode.make(3, undefined, undefined)), Caml_option.some(TreeNode.make(7, undefined, undefined)));

var n15 = TreeNode.make(15, undefined, Caml_option.some(TreeNode.make(18, undefined, undefined)));

var root1 = TreeNode.make(10, Caml_option.some(n5), Caml_option.some(n15));

var r1 = symmetricTree(root1);

console.log("r1: ", r1);

var symmetric = TreeNode.make(1, Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(3, undefined, undefined)), Caml_option.some(TreeNode.make(4, undefined, undefined)))), Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(4, undefined, undefined)), Caml_option.some(TreeNode.make(3, undefined, undefined)))));

var r2 = symmetricTree(symmetric);

console.log("r2: ", r2);

export {
  symmetricTree ,
  n5 ,
  n15 ,
  root1 ,
  r1 ,
  symmetric ,
  r2 ,
}
/* n5 Not a pure module */
