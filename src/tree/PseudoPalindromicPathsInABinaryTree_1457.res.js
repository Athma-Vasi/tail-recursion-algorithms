// Generated by ReScript, PLEASE EDIT WITH CARE

import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function pseudoPalindromicPathsInABinaryTree(root) {
  var preorderTraverse = function (_paths, _stack) {
    while(true) {
      var stack = _stack;
      var paths = _paths;
      if (!stack) {
        return paths;
      }
      var match = stack.hd;
      var node = match[0];
      var right = node.right;
      var left = node.left;
      var rest = stack.tl;
      var newPath_0 = node.val;
      var newPath_1 = match[1];
      var newPath = {
        hd: newPath_0,
        tl: newPath_1
      };
      if (left !== undefined) {
        if (right !== undefined) {
          _stack = {
            hd: [
              left,
              newPath
            ],
            tl: {
              hd: [
                right,
                newPath
              ],
              tl: rest
            }
          };
          continue ;
        }
        _stack = {
          hd: [
            left,
            newPath
          ],
          tl: rest
        };
        continue ;
      }
      if (right !== undefined) {
        _stack = {
          hd: [
            right,
            newPath
          ],
          tl: rest
        };
        continue ;
      }
      _stack = rest;
      _paths = {
        hd: newPath,
        tl: paths
      };
      continue ;
    };
  };
  if (root !== undefined) {
    return Core__Array.reduce(Core__List.toArray(Core__List.reverse(preorderTraverse(/* [] */0, {
                              hd: [
                                root,
                                /* [] */0
                              ],
                              tl: /* [] */0
                            }))), new Set(), (function (acc, paths) {
                    var freqTable = Core__Array.reduce(Core__List.toArray(Core__List.reverse(paths)), new Map(), (function (mapAcc, path) {
                            var freq = Core__Option.mapOr(mapAcc.get(path), 1, (function (f) {
                                    return f + 1 | 0;
                                  }));
                            mapAcc.set(path, freq);
                            return mapAcc;
                          }));
                    var isPathPseudoPalindromic = Core__Array.reduce(Array.from(freqTable.values()), 0, (function (countAcc, count) {
                            if (count % 2.0 === 0.0) {
                              return countAcc;
                            } else {
                              return countAcc + 1 | 0;
                            }
                          })) <= 1;
                    acc.add(isPathPseudoPalindromic);
                    return acc;
                  })).has(true);
  } else {
    return false;
  }
}

var tree = TreeNode.make(2, Caml_option.some(TreeNode.make(3, Caml_option.some(TreeNode.make(3, undefined, undefined)), Caml_option.some(TreeNode.make(1, undefined, undefined)))), Caml_option.some(TreeNode.make(1, undefined, Caml_option.some(TreeNode.make(1, undefined, undefined)))));

var r1 = pseudoPalindromicPathsInABinaryTree(tree);

console.log("r1: ", r1);

var n5 = TreeNode.make(5, Caml_option.some(TreeNode.make(3, undefined, undefined)), Caml_option.some(TreeNode.make(7, undefined, undefined)));

var n15 = TreeNode.make(15, undefined, Caml_option.some(TreeNode.make(18, undefined, undefined)));

var root1 = TreeNode.make(10, Caml_option.some(n5), Caml_option.some(n15));

var r2 = pseudoPalindromicPathsInABinaryTree(root1);

console.log("r2: ", r2);

export {
  pseudoPalindromicPathsInABinaryTree ,
  tree ,
  r1 ,
  n5 ,
  n15 ,
  root1 ,
  r2 ,
}
/* tree Not a pure module */
