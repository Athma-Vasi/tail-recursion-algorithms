// Generated by ReScript, PLEASE EDIT WITH CARE

import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function binaryTreeTilt(root) {
  var postorderTraverse = function (_rpnStack, _workingStack) {
    while(true) {
      var workingStack = _workingStack;
      var rpnStack = _rpnStack;
      if (!workingStack) {
        return rpnStack;
      }
      var top = workingStack.hd;
      var right = top.right;
      var left = top.left;
      var val = top.val;
      var rest = workingStack.tl;
      if (left !== undefined) {
        if (right !== undefined) {
          _workingStack = {
            hd: right,
            tl: {
              hd: left,
              tl: rest
            }
          };
          _rpnStack = {
            hd: [
              val,
              "Branch",
              2
            ],
            tl: rpnStack
          };
          continue ;
        }
        _workingStack = {
          hd: left,
          tl: rest
        };
        _rpnStack = {
          hd: [
            val,
            "Branch",
            1
          ],
          tl: rpnStack
        };
        continue ;
      }
      if (right !== undefined) {
        _workingStack = {
          hd: right,
          tl: rest
        };
        _rpnStack = {
          hd: [
            val,
            "Branch",
            1
          ],
          tl: rpnStack
        };
        continue ;
      }
      _workingStack = rest;
      _rpnStack = {
        hd: [
          val,
          "Leaf",
          0
        ],
        tl: rpnStack
      };
      continue ;
    };
  };
  if (root !== undefined) {
    var _rpnStack = postorderTraverse(/* [] */0, {
          hd: root,
          tl: /* [] */0
        });
    var _tiltSum = 0;
    var _evalStack = /* [] */0;
    while(true) {
      var evalStack = _evalStack;
      var tiltSum = _tiltSum;
      var rpnStack = _rpnStack;
      if (!rpnStack) {
        return tiltSum;
      }
      var rest = rpnStack.tl;
      var match = rpnStack.hd;
      var leavesCount = match[2];
      var nodeKind = match[1];
      var val = match[0];
      if (nodeKind === "Leaf") {
        _evalStack = {
          hd: [
            val,
            nodeKind,
            0
          ],
          tl: evalStack
        };
        _rpnStack = rest;
        continue ;
      }
      var match$1 = Core__List.reduceWithIndex(evalStack, [
            /* [] */0,
            /* [] */0
          ], (function(leavesCount){
          return function (acc, curr, idx) {
            var sliced = acc[1];
            var topLeaves = acc[0];
            if (idx < leavesCount && curr[1] === "Leaf") {
              return [
                      {
                        hd: curr,
                        tl: topLeaves
                      },
                      sliced
                    ];
            } else {
              return [
                      topLeaves,
                      {
                        hd: curr,
                        tl: sliced
                      }
                    ];
            }
          }
          }(leavesCount)));
      var topLeaves = match$1[0];
      var match$2;
      if (topLeaves) {
        var match$3 = topLeaves.tl;
        var leftSum = topLeaves.hd[0];
        if (match$3) {
          var rightSum = match$3.hd[0];
          var tilt = PervasivesU.abs(leftSum - rightSum | 0);
          var subtreeSum = (val + leftSum | 0) + rightSum | 0;
          match$2 = [
            tiltSum + tilt | 0,
            subtreeSum
          ];
        } else {
          match$2 = [
            tiltSum + PervasivesU.abs(leftSum) | 0,
            val + leftSum | 0
          ];
        }
      } else {
        match$2 = [
          tiltSum,
          val
        ];
      }
      _evalStack = {
        hd: [
          match$2[1],
          "Leaf",
          0
        ],
        tl: match$1[1]
      };
      _tiltSum = match$2[0];
      _rpnStack = rest;
      continue ;
    };
  } else {
    return -1;
  }
}

var tree1 = TreeNode.make(1, Caml_option.some(TreeNode.make(2, undefined, undefined)), Caml_option.some(TreeNode.make(3, undefined, undefined)));

var r1 = binaryTreeTilt(tree1);

console.log("r1: ", r1);

var tree2 = TreeNode.make(4, Caml_option.some(TreeNode.make(2, Caml_option.some(TreeNode.make(3, undefined, undefined)), Caml_option.some(TreeNode.make(5, undefined, undefined)))), Caml_option.some(TreeNode.make(9, undefined, Caml_option.some(TreeNode.make(7, undefined, undefined)))));

var r2 = binaryTreeTilt(tree2);

console.log("r2: ", r2);

var tree3 = TreeNode.make(21, Caml_option.some(TreeNode.make(7, Caml_option.some(TreeNode.make(1, Caml_option.some(TreeNode.make(3, undefined, undefined)), Caml_option.some(TreeNode.make(3, undefined, undefined)))), Caml_option.some(TreeNode.make(1, undefined, undefined)))), Caml_option.some(TreeNode.make(14, Caml_option.some(TreeNode.make(2, undefined, undefined)), Caml_option.some(TreeNode.make(2, undefined, undefined)))));

var r3 = binaryTreeTilt(tree3);

console.log("r3: ", r3);

export {
  binaryTreeTilt ,
  tree1 ,
  r1 ,
  tree2 ,
  r2 ,
  tree3 ,
  r3 ,
}
/* tree1 Not a pure module */
