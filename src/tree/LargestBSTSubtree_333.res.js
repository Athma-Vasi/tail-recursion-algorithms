// Generated by ReScript, PLEASE EDIT WITH CARE

import * as TreeNode from "./TreeNode.res.js";
import * as Core__List from "@rescript/core/src/Core__List.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function largestBSTSubtree(root) {
  var postorderTraverse = function (_rpnStack, nodeLeavesCountTable, _workingStack) {
    while(true) {
      var workingStack = _workingStack;
      var rpnStack = _rpnStack;
      if (!workingStack) {
        return [
                rpnStack,
                nodeLeavesCountTable
              ];
      }
      var top = workingStack.hd;
      var right = top.right;
      var left = top.left;
      var rest = workingStack.tl;
      if (left !== undefined) {
        if (right !== undefined) {
          nodeLeavesCountTable.set(top, 2);
          _workingStack = {
            hd: right,
            tl: {
              hd: left,
              tl: rest
            }
          };
          _rpnStack = {
            hd: [
              top,
              "Branch"
            ],
            tl: rpnStack
          };
          continue ;
        }
        nodeLeavesCountTable.set(top, 1);
        _workingStack = {
          hd: left,
          tl: rest
        };
        _rpnStack = {
          hd: [
            top,
            "Branch"
          ],
          tl: rpnStack
        };
        continue ;
      }
      if (right !== undefined) {
        nodeLeavesCountTable.set(top, 1);
        _workingStack = {
          hd: right,
          tl: rest
        };
        _rpnStack = {
          hd: [
            top,
            "Branch"
          ],
          tl: rpnStack
        };
        continue ;
      }
      nodeLeavesCountTable.set(top, 0);
      _workingStack = rest;
      _rpnStack = {
        hd: [
          top,
          "Leaf"
        ],
        tl: rpnStack
      };
      continue ;
    };
  };
  if (root === undefined) {
    return -1;
  }
  var match = postorderTraverse(/* [] */0, new Map(), {
        hd: root,
        tl: /* [] */0
      });
  var _rpnStack = match[0];
  var nodeLeavesCountTable = match[1];
  var _largestSize = 0;
  var _evaluationStack = /* [] */0;
  while(true) {
    var evaluationStack = _evaluationStack;
    var largestSize = _largestSize;
    var rpnStack = _rpnStack;
    if (!rpnStack) {
      return largestSize;
    }
    var rest = rpnStack.tl;
    var match$1 = rpnStack.hd;
    var nodeKind = match$1[1];
    var node = match$1[0];
    if (nodeKind === "Leaf") {
      _evaluationStack = {
        hd: [
          node.val,
          nodeKind,
          0
        ],
        tl: evaluationStack
      };
      _rpnStack = rest;
      continue ;
    }
    var leavesCount = Core__Option.getOr(nodeLeavesCountTable.get(node), 0);
    var match$2 = Core__List.reduceWithIndex(evaluationStack, [
          /* [] */0,
          /* [] */0
        ], (function(leavesCount){
        return function (acc, curr, idx) {
          var subtreeSize = curr[2];
          var nodeKind = curr[1];
          var val = curr[0];
          var sliced = acc[1];
          var topLeaves = acc[0];
          if (idx < leavesCount && nodeKind === "Leaf") {
            return [
                    {
                      hd: [
                        val,
                        subtreeSize
                      ],
                      tl: topLeaves
                    },
                    sliced
                  ];
          } else {
            return [
                    topLeaves,
                    {
                      hd: [
                        val,
                        nodeKind,
                        subtreeSize
                      ],
                      tl: sliced
                    }
                  ];
          }
        }
        }(leavesCount)));
    var topLeaves = match$2[0];
    var match$3 = Core__List.size(topLeaves) === 2 ? Core__List.reduceReverse(topLeaves, [
            /* [] */0,
            0
          ], (function (acc, param) {
              return [
                      {
                        hd: param[0],
                        tl: acc[0]
                      },
                      acc[1] + param[1] | 0
                    ];
            })) : [
        /* [] */0,
        0
      ];
    var leavesValues = match$3[0];
    var newLargestSize;
    if (leavesValues) {
      var restSizes = leavesValues.tl;
      if (restSizes && leavesValues.hd < node.val && node.val < restSizes.hd) {
        var newBSTSize = match$3[1] + 1 | 0;
        newLargestSize = largestSize > newBSTSize ? largestSize : newBSTSize;
      } else {
        newLargestSize = largestSize;
      }
    } else {
      newLargestSize = largestSize;
    }
    _evaluationStack = {
      hd: [
        node.val,
        "Leaf",
        newLargestSize
      ],
      tl: match$2[1]
    };
    _largestSize = newLargestSize;
    _rpnStack = rest;
    continue ;
  };
}

var tree1 = TreeNode.make(10, Caml_option.some(TreeNode.make(5, Caml_option.some(TreeNode.make(1, undefined, undefined)), Caml_option.some(TreeNode.make(8, undefined, undefined)))), Caml_option.some(TreeNode.make(15, undefined, Caml_option.some(TreeNode.make(7, undefined, undefined)))));

var r1 = largestBSTSubtree(tree1);

console.log("r1: ", r1);

export {
  largestBSTSubtree ,
  tree1 ,
  r1 ,
}
/* tree1 Not a pure module */
