// Generated by ReScript, PLEASE EDIT WITH CARE

import * as TreeNode from "./TreeNode.res.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function checkIfTwoExpressionTreesAreEquivalent(root1, root2) {
  var inorderTraverse = function (charsFreqs1, charsFreqs2, _curr1, _curr2, _stack1, _stack2) {
    while(true) {
      var stack2 = _stack2;
      var stack1 = _stack1;
      var curr2 = _curr2;
      var curr1 = _curr1;
      if (curr1 !== undefined) {
        if (curr2 !== undefined) {
          _stack2 = {
            hd: curr2,
            tl: stack2
          };
          _stack1 = {
            hd: curr1,
            tl: stack1
          };
          _curr2 = curr2.left;
          _curr1 = curr1.left;
          continue ;
        }
        _stack1 = {
          hd: curr1,
          tl: stack1
        };
        _curr2 = undefined;
        _curr1 = curr1.left;
        continue ;
      }
      if (curr2 !== undefined) {
        _stack2 = {
          hd: curr2,
          tl: stack2
        };
        _curr2 = curr2.left;
        _curr1 = undefined;
        continue ;
      }
      if (stack1) {
        var rest1 = stack1.tl;
        var top1 = stack1.hd;
        if (stack2) {
          var top2 = stack2.hd;
          var freq1 = Core__Option.mapOr(charsFreqs1.get(top1.val), 1, (function (f) {
                  return f + 1 | 0;
                }));
          charsFreqs1.set(top1.val, freq1);
          var freq2 = Core__Option.mapOr(charsFreqs2.get(top2.val), 1, (function (f) {
                  return f + 1 | 0;
                }));
          charsFreqs2.set(top2.val, freq2);
          _stack2 = stack2.tl;
          _stack1 = rest1;
          _curr2 = top2.right;
          _curr1 = top1.right;
          continue ;
        }
        var val = top1.val;
        var freq1$1 = Core__Option.mapOr(charsFreqs1.get(val), 1, (function (f) {
                return f + 1 | 0;
              }));
        charsFreqs1.set(val, freq1$1);
        _stack1 = rest1;
        _curr1 = top1.right;
        continue ;
      }
      if (!stack2) {
        return [
                charsFreqs1,
                charsFreqs2
              ];
      }
      var top2$1 = stack2.hd;
      var val$1 = top2$1.val;
      var freq2$1 = Core__Option.mapOr(charsFreqs2.get(val$1), 1, (function (f) {
              return f + 1 | 0;
            }));
      charsFreqs2.set(val$1, freq2$1);
      _stack2 = stack2.tl;
      _curr2 = top2$1.right;
      continue ;
    };
  };
  var match = inorderTraverse(new Map(), new Map(), root1, root2, /* [] */0, /* [] */0);
  var charsFreqs2 = match[1];
  if (Core__Array.reduce(Array.from(match[0].entries()), new Set(), (function (acc, param) {
              var freq2 = charsFreqs2.get(param[0]);
              return freq2 !== undefined ? (acc.add(param[1] === freq2), acc) : (acc.add(false), acc);
            })).has(false)) {
    return false;
  } else {
    return true;
  }
}

var tree1 = TreeNode.make("+", Caml_option.some(TreeNode.make("a", undefined, undefined)), Caml_option.some(TreeNode.make("+", Caml_option.some(TreeNode.make("b", undefined, undefined)), Caml_option.some(TreeNode.make("c", undefined, undefined)))));

var tree2 = TreeNode.make("+", Caml_option.some(TreeNode.make("+", Caml_option.some(TreeNode.make("c", undefined, undefined)), Caml_option.some(TreeNode.make("a", undefined, undefined)))), Caml_option.some(TreeNode.make("b", undefined, undefined)));

var r1 = checkIfTwoExpressionTreesAreEquivalent(tree1, tree2);

console.log("r1: ", r1);

var tree3 = TreeNode.make("+", Caml_option.some(TreeNode.make("a", undefined, undefined)), Caml_option.some(TreeNode.make("+", Caml_option.some(TreeNode.make("b", undefined, undefined)), Caml_option.some(TreeNode.make("c", undefined, undefined)))));

var tree4 = TreeNode.make("+", Caml_option.some(TreeNode.make("+", Caml_option.some(TreeNode.make("d", undefined, undefined)), Caml_option.some(TreeNode.make("a", undefined, undefined)))), Caml_option.some(TreeNode.make("b", undefined, undefined)));

var r2 = checkIfTwoExpressionTreesAreEquivalent(tree3, tree4);

console.log("r2: ", r2);

export {
  checkIfTwoExpressionTreesAreEquivalent ,
  tree1 ,
  tree2 ,
  r1 ,
  tree3 ,
  tree4 ,
  r2 ,
}
/* tree1 Not a pure module */
